**HTML解析**

  - 将parser单独拆分到文件中，parser接受HTML文本作为参数，返回一颗DOM树
  - 使用FSM实现对HTML的分析，HTML标准已经规定HTML的状态，我们只会挑选一部分状态，完成最简单的版本
  - 分析主要的标签有，开始标签，结束标签和自封闭标签，在本步骤暂时忽略所有的属性
  - 在状态机中，除了状态迁移，还要加入业务逻辑，并且在标签结束时候提交状态token
  - 属性值分为单引号，双引号，无引号三种写法，需要较多的状态处理，属性结束时把属性加到标签的token上
  - 从标签构建DOM树的基本技巧是使用栈，遇到开始标签时创建元素并入栈，遇到结束标签出栈
  - 自封闭节点可视为入栈后立刻出栈，任何元素的父元素是它入栈前的栈顶
  - 文本节点与自封闭标签处理类似，多个文本节点需要合并

  

- **CSS计算**

  - 遇到style标签，把css规则保存起来并且调用CSS parser 来分析css规则（需要仔细研究分析此库分析css规则的格式）
  - 当创建一个元素后，立即计算css，
  - 理论上当分析第一个元素的时候，所有css的规则已经收集完毕
  - 在真实的浏览器中会遇到body的style标签，需要重新计算css的情况（暂时忽略）
  - 在computedCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配（从上一步骤的stack可以获取到父元素），因为我们首先获取的是‘当前元素’，所以我们获得和计算父元素匹配的顺序是从内向外
  - 选择器也要从当前元素向外排列，复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列
  - 根据选择器的类型和元素属性，计算是否与当前元素匹配
  - 一旦选择匹配，就应用选择器到元素上，形成computedStyle
  - css规则根据specificity和后来优先规则覆盖
  - specificity是个四元组，越左边权重越高
  - 一个css规则的specificity根据包含的简单选择器相加而成

**正则**

- \f  匹配一个换页符 (U+000C)
- \n  匹配一个换行符 (U+000A)
- \r  匹配一个回车符 (U+000D)


**目前发现自己的问题**

- 对正则表达式的掌握非常薄弱，需要加强这块的理解
- 没有整块的时间去进行学习并且基本只能有一遍刷视频的机会的情况下，都是在公司八点半之后去刷一个小时的视频学习，会出现注意力不集中的问题，导致对有些逻辑理解的不是很清晰，需要去挤出时间再去理解一下老师的思路
